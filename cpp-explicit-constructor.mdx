# Explicit Constructor

_The `explicit` specifier has been extended since C++17; this section focuses on its use with constructors._

The `explicit` specifier prevents the compiler from treating a constructor as a converting constructor. To illustrate what a converting constructor is and how it is used, consider the following class definition regarding a RGBA color type:

```cpp
class RGBA
{
private:
    // ... members

public:
    RGBA(const uint8_t red, const uint8_t green, const uint8_t blue, const uint8_t alpha = 255)
    {
		// ... initialization
    }

	// Generate debug outputs
    std::string debug_string() const;
};
```

In a specific renderer, the alpha channel is unsupported and will be ignored in its `fill_something` method. To prevent confusion for callers interpreting the omission of alpha as a bug, or accidentally specifying an alpha value, we introduce a new class `RGB` without an alpha channel. This is defined as follows:

```cpp
class RGB
{
private:
    // ... members

public:
    RGB(const RGBA& rgba)
    {
        debug_logger << "Dropping the alpha channel from " << rgba.debug_string();
		// ... more initialization
    }
};

void fill_something(const RGB& rgb)
{
    // Fill something but doesn't support the alpha channel
}
```

Now, when calling `fill_something`, the user can clearly see that the alpha channel is ignored:

```cpp
const RGBA rgba_red{255, 0, 0, 255};
const RGB rgb_red{rgba_red};
fill_something(rgb_red);
```

However, surprisingly, the following invocation does **not** result in a compiler error. Instead, `fill_something` is successfully invoked, with the alpha channel of the parameter being silently dropped:

```cpp
const RGBA semi_transparent_red{255, 0, 0, 128};
fill_something(semi_transparent_red);
```

This undermines our design goal of ensuring that callers are aware of the alpha drop. The reason this works is due to _implicit conversion_: the compiler recognizes that `RGB(const RGBA& rgba)` accepts a `RGBA&` and constructs an `RGB` instance, treating it as an implicit conversion tool, officially referred to as a [converting constructor](https://en.cppreference.com/w/cpp/language/converting_constructor). The compiler effectively transforms the call into the following:

```cpp
const RGBA semi_transparent_red{255, 0, 0, 128};
fill_something(RGB(semi_transparent_red)); // A new RGB object is created based on the parameter.
```

Using the `explicit` specifier ensures that the compiler does not treat our constructor as a part of implicit conversions. By adding `explicit` to `RGB`'s constructor, `fill_something` can no longer be called with a `RGBA` parameter:

```cpp
class RGB
{
private:
    // ... members

public:
    explicit RGB(const RGBA& rgba)
    {
        std::cout << "Dropping the alpha channel from " << rgba.debug_string() << std::endl;
		// ... more initialization
    }
};

// ...
const RGBA semi_transparent_red{255, 0, 0, 128};
fill_something(semi_transparent_red); // ERROR!
// Build error: 
//    no matching function for call to 'fill_something';
//    candidate function not viable: no known conversion from 'const RGBA' to 'const RGB' for 1st argument
```

Now, to call `fill_something` with a `RGBA` instance, the caller must take one of the following approaches. All of these are _explicit conversions_, reminding the caller about the alpha channel drop:

```cpp
fill_something(static_cast<RGB>(semi_transparent_red));
fill_something(RGB{semi_transparent_red});
fill_something(RGB(semi_transparent_red));
fill_something((RGB)semi_transparent_red); // Not recommended; prefer static_cast.
```

As a general rule, avoid defining implicit conversions. Use the `explicit` keyword for conversion operators and single-argument constructors, except in rare cases, such as when types are designed to be interchangeable (see [Implicit Conversions, Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html#Implicit_Conversions)).