# Explicit Constructor

_The `explicit` specifier has been extended since c++17, this paragraph only covers its usage with constructors._

The `explicit` specifier is used to demand the compiler not treat a constructor as converting constructor. To understand what the converting constructor is and how it is used, assume we have following existing class definition:

```clike
class RGBA
{
private:
    // ... members

public:
    RGBA(const uint8_t red, const uint8_t green, const uint8_t blue, const uint8_t alpha = 255)
    {
		// ... more initialization
    }

	// generate debug outputs
    std::string debug_string() const;
};
```

However for a certain renderer, alpha channel isn't supported and will be ignored in its `fill_something` method. To avoid confuse callers by accidently specifying the alpha value, or considering losing of alpha as a bug, we decided to add a new class `RGB` which doesn't have the alpha channel, and use it in the related method, which is defined as

```clike
class RGB
{
private:
    // ... members

public:
    RGB(const RGBA& rgba)
    {
        std::cout << "drop the alpha channel from " << rgba.debug_string() << std::endl;
		// ... more initialization
    }
};

void fill_something(const RGB& rgb)
{
    // fill something but doesn't support the alpha channel
}
```

Thus a caller of the `fill_something` is able to obtain a clear view that the alpha channel will be ignored by writing:

```clike
    const RGBA rgba_red{255, 0, 0, 255};
    const RGB rgb_red{rgba_red};
    fill_something(rgb_red);
```

However, suprisingly, following invocation does **NOT** lead to compiler errors; instead the `fill_something` is still invoked, meanwhile the alpha channel of the parameter is silently dropped:

```clike
    const RGBA semi_transparent_red{255, 0, 0, 128};
    fill_something(semi_transparent_red);
```

It invalidates our design scope that a caller should be aware of alpha dropping when writing the code. The reason that above invocation works is because the _implicit conversion_: the compiler finds the `RGB(const RGBA& rgba)` takes one parameter of `RGBA&` and constructs an `RGB` instance, so it treats it as an implicit convertor which is officially named as [converting constructor](https://en.cppreference.com/w/cpp/language/converting_constructor). Concepturally, the compiler converts the invocation into following:

```clike
    const RGBA semi_transparent_red{255, 0, 0, 128};
    fill_something(RGB(semi_transparent_red)); // Note that a new RGB object is created based on the parameter.
```